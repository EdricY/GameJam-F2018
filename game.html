<!DOCTYPE html>
<html>
<meta charset="UTF-8">
    <title>THE GAME TITLE!</title>

    <style>
        body {
            display: flex;
            flex-flow: column;
            align-items: center;
            justify-content: center;
        }
        .center{
            flex: 1;
        }
        #players_ul{
            display: table;
            margin: 100px auto;
        }
        #readybtn{
            margin: 0 auto;
            display: table;
            margin-top: 10px;
        }
        #gamediv{
            margin-top: 20px;
        }

    </style>
          
</head>
<body id="body">

    <div id="connectdiv">
        <div id="connectmsg"></div>
        <ul id="players_ul"></ul>
        <div id="buttonsdiv">
            <button type="button" id="readybtn" onclick="sendReady(true)">Ready!</button>
            <button type="button" id="readybtn" onclick="sendReady(false)">Hold On...</button>
        </div>
    </div>
              

    <div id="gamediv" class="center">
        <!-- <div hidden id="loadmsg">
            Loading...
        </div> -->
        <canvas id="canvas" width="768" height="512"></canvas>
        <canvas hidden id="renderer" width="768" height="512"></canvas>
        <canvas hidden id="alphacanvas" width="768" height="512"></canvas>
        <canvas hidden id="frameloader" width="32" height="32"></canvas>
    </div>
<!-- alpha drawing: https://weblogs.asp.net/bleroy/drawing-transparent-glyphs-on-the-html-canvas-->
</body>

<img hidden id='frame0' src='Frames/frame_0.png' alt='img'>
<img hidden id='frame1' src='Frames/frame_1.png' alt='img'>
<img hidden id='frame2' src='Frames/frame_2.png' alt='img'>
<img hidden id='frame3' src='Frames/frame_3.png' alt='img'>
<img hidden id='frame4' src='Frames/frame_4.png' alt='img'>
<img hidden id='frame5' src='Frames/frame_5.png' alt='img'>

<img hidden id="Wood" src="Tiles/Wood.png" alt="tileimg">
<img hidden id="Water" src="Tiles/Water.png" alt="tileimg">
<img hidden id="Stone" src="Tiles/Stone.png" alt="tileimg">
<img hidden id="Sand" src="Tiles/Sand.png" alt="tileimg">
<img hidden id="Metal" src="Tiles/Metal.png" alt="tileimg">
<img hidden id="Grass" src="Tiles/Grass.png" alt="tileimg">
<img hidden id="Dirt" src="Tiles/Dirt.png" alt="tileimg">
<img hidden id="Brick" src="Tiles/Brick.png" alt="tileimg">


<img hidden id='tileimg' src='tile.png' alt='img'>

<script type="text/javascript" src="particles.js"></script>
<script type="text/javascript">
var canvas = document.getElementById('canvas')
var renderer = document.getElementById('renderer')
var frameloader = document.getElementById('frameloader')
var alphacanvas = document.getElementById('alphacanvas')
var vis_ctx = canvas.getContext('2d')
var ctx = renderer.getContext('2d')
var fl_ctx = frameloader.getContext('2d')
var a_ctx = alphacanvas.getContext('2d')
var keys = {};
var lastKeys = {};
var lastTime
var cameravx = 0.5;
var mouseX = 0;
var mouseY = 0;

var socket;
var myServer = getParameterByName('s')
var myName = getParameterByName('n')
var myChoice = getParameterByName('c')
var mySID;

var playing = false;

var W = renderer.width
var H = renderer.height
var worldW;
const TILES = {
    '0,0,0,0': null, //background
    '76,255,0,255': 0,
    '127,106,0,255': 1,
    '127,0,0,255': 2,
    '0,38,255,255': 3,
    '128,128,128,255': 4,
    '255,216,0,255': 5,
    '255,0,110,255': 6,
    '0,0,0,255': 7,
}

//packet types
const SERVER_PLAYING = -4,
 SERVER_FULL = -3,
 PLAYERLIST = -2,
 READY = -1,
 CONNECT = 0,
 TICK = 1,
 EXPLODE = 2;


const GRAVITY = 1;
const FRICTION = .85;
const BOMB_FRICTION = .97;
var tileimgdata = []
var worldframeimgdatas = [] // actual world data
var worldframes = [] // heavyweight version of frames (same for all)
var worldframeorder = [] // get this from server
var frames = [] //lightweight version of frames
var bombs = [];
var camerax = 0;
var lastTime = Date.now();

var numPlayers;

var otherplayers = [];

const frameHtmlImgs = [
    frame0,
    frame1,
    frame2,
    frame3,
    frame4,
    frame5,
]
const tileHtmlImgs = [
    Grass,
    Dirt,
    Brick,
    Water,
    Metal,
    Sand,
    Wood,
    Stone,
]

var player = {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    w: 32,
	h: 64,
    ax: .6,
	jv: -18,
	mvx: 50,
	mvy: 20,
	jumps: 1,
    step_h: 16,
    midair: true,
    bombCooldown: 0,
    draw() {
        drawPlayer(this.x, this.y, this.w, this.h, 'red')
    },
    update() {
        if(this.bombCooldown > 0) {
            this.bombCooldown -= 1
        }
        this.vy += GRAVITY;
        if (keys[37] || keys[65]) { //left
            this.vx -= this.ax;
            if (this.vx < -this.maxv)
                this.vx = -this.maxv;
        }
        if (keys[39] || keys[68]) { //right
            this.vx += this.ax;
            if (this.vx > this.maxv)
                this.vx = this.maxv;
        }
        if (keys[0] && !lastKeys[0] && this.bombCooldown === 0) {
            this.bombCooldown = 100;
            let dx = (mouseX + camerax) - this.x
            let dy = mouseY - this.y
            let dc = Math.sqrt(dx ** 2 + dy ** 2)
            let bvx = dx / dc * 20
            let bvy = dy / dc * 20
            bombs[mySID].push(makeBomb(this.x + this.w/2, this.y + this.h/2, bvx, bvy));
        }
        if (this.jumps && (keys[38] || keys[87]) && (!lastKeys[38] && !lastKeys[87])) { //up
            this.vy = -18;
        }
        if (this.vy >= 0) { //moving down
            let y_cls = findYCollisionDown(this.y, this.vy, this.x, this.w, this.h);
            if (y_cls == null) {
                this.y += this.vy;
                this.midair = true;
            } else { //landed on something
                this.vy = 0;
                this.y = y_cls.y;
                this.midair = false;
            }
        } else { //moving up
            let y_cls = findYCollisionUp(this.y, this.vy, this.x, this.w, this.h);
            this.midair = true;
            if (y_cls == null) {
                this.y += this.vy;
            } else { //hit your head
                this.vy = 0;
                this.y = y_cls.y;
                this.midair = false;
            }
        }
        if (this.vx > 0) { //moving right
            let x_cls = findXCollisionRight(this.x, this.vx, this.y, this.w, this.h);
            if (x_cls == null) this.x += this.vx;
            else { //hit wall
                let step_h = this.y + this.h - x_cls.y;
                if (step_h <= this.step_h) {
                    this.x = x_cls.x + 1;
                    this.y -= step_h; //not implemented: climbing more than 1 step
                } else {
                    this.vx = 0;
                    this.x = x_cls.x;
                }
            }
        } else if(this.vx < 0) { //moving left
            let x_cls = findXCollisionLeft(this.x, this.vx, this.y, this.w, this.h);
            if (x_cls == null) this.x += this.vx;
            else { //hit wall
                let step_h = this.y + this.h - x_cls.y;
                if (step_h <= this.step_h) {
                    this.x = x_cls.x - 1;
                    this.y -= step_h; //not implemented: climbing more than 1 step
                } else {
                    this.vx = 0;
                    this.x = x_cls.x;
                }
            }
        }
        this.vx *= FRICTION;
        if (Math.abs(this.vx) - .01 < 0) {
            this.vx = 0;
        }
    }
}

function drawPlayer(x, y, w, h, color) {
    ctx.fillStyle = color;
    let f_x = Math.floor(x - camerax);
    let f_y = Math.floor(y);
    ctx.fillRect(f_x, f_y, w, h, color);
    
}

function connect() {
	connectmsg.innerText = "Connecting...";
    var url = 'ws://' + myServer + ':8191';
    socket = new WebSocket(url);
    socket.onopen = function () {
		connectmsg.hidden = true;
		gamediv.hidden = false;
		document.getElementById("body").style.backgroundColor = "#888";
		socket.send(newPacket(CONNECT, {name: myName, choice: myChoice}));
        buttonsdiv.hidden = false;
    }
    socket.onclose = e => {
        console.log('close')
        connectdiv.hidden = false;
		connectmsg.hidden = false;
        gamediv.hidden = true;
        players_ul.hidden = true;
        players_ul.style.display = 'none';
        gamediv.style.display = 'none';
        document.getElementById("body").style.backgroundColor = "#FFF";
		connectmsg.innerText = "Connection Closed. You can try reloading, but the server is probably down.";
        buttonsdiv.hidden = true;
        playing = false;
        if (gameInt) clearInterval(gameInt);
    }
    socket.onmessage = e => { // Packet Reception
        let data = JSON.parse(e.data);
        if (data.type == PLAYERLIST) { //used before game starts
            replacePlayerList(data.obj.playerlist);
        } else if (data.type == SERVER_PLAYING) {
            connectmsg.innerText = 'Server is Full!'
        } else if (data.type == READY) {
            playing = true;
            mySID = data.obj.id
            worldframeorder = data.obj.f_ord
            worldW = worldframeorder.length * W;
            player.x = data.obj.x
            numPlayers = data.obj.num
            for (let i = 0; i < numPlayers; i++) {
                bombs.push([])
            }
            connectdiv.hidden = true;
            initGame();
        } else if (data.type == TICK) {
            let obj = data.obj;
            camerax = obj.cx;
            otherplayers = obj.p;
            for (let listi in obj.b) {
                if (listi != mySID){
                    bombs[listi] = obj.b[listi];
                }
            }

        }  else if (data.type == EXPLODE) {
            explode(data.obj.x, data.obj.y, data.obj.r)
        }
    }
}

function sendReady(status) {
    socket.send(newPacket(READY, status))
}


function newPacket(type, obj){
	return JSON.stringify({'type': type, 'obj': obj});
}

function replacePlayerList(playerlist){
    while (players_ul.hasChildNodes()) {
        players_ul.removeChild(players_ul.lastChild);
    }
    for (let p of playerlist) {
        let readyText = p.ready ? "" : ": Waiting..."
        let node = document.createTextNode(p.name + readyText);
        let lsit = document.createElement("li");
        lsit.appendChild(node);
        lsit.style.color = p.ready ? "green" : "red"
        lsit.style.padding = '10px';
        players_ul.appendChild(lsit);
    }
}


function makeBomb(x, y, vx, vy) {
    var bomb = {
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        rw: 5,
        rh: 5,
        countdown: 100,
        getAsObj() {
            return {x:this.x, y:this.y, rh: this.rh, rw: this.rw}
        },
        update() {
            this.countdown -= 1;
            if(this.countdown == 0) {
                bombs[mySID].pop()
                socket.send(newPacket(EXPLODE, { 
                    x: this.x,
                    y: this.y,
                    r: 50
                }))
            }
            this.vy += GRAVITY;
            if (this.vy >= 0) { //moving down
                let y_cls = findYCollisionDown(this.y, this.vy, this.x, this.rw, this.rh);
                if (y_cls == null) { 
                    this.y += this.vy;
                } else { //landed on something
                    this.vy = this.vy * -0.7;;
                    this.y = y_cls.y;
                }
            } else { //moving up
                let y_cls = findYCollisionUp(this.y, this.vy, this.x, this.rw, this.rh);
                if (y_cls == null) {
                    this.y += this.vy;
                } else { //hit your head
                    this.vy = this.vy * -0.7;;
                    this.y = y_cls.y;
                }
            }
            if (this.vx > 0) { //moving right
                let x_cls = findXCollisionRight(this.x, this.vx, this.y, this.rw, this.rh);
                if (x_cls == null) this.x += this.vx;
                else { //hit wall
                    this.vx = this.vx * -0.7;
                    this.x = x_cls.x;
                }
            } else if(this.vx < 0) { //moving left
                let x_cls = findXCollisionLeft(this.x, this.vx, this.y, this.rw, this.rh);
                if (x_cls == null) this.x += this.vx;
                else { //hit wall
                    this.vx = this.vx * -0.7;
                    this.x = x_cls.x;
                }
            }
            this.vx *= BOMB_FRICTION;
            if (Math.abs(this.vx) - .01 < 0) {
                this.vx = 0;
            }
        }
    }
    return bomb;
}

function drawBomb(x, y, rw, rh, color) {
    let f_x = Math.floor(x - camerax);
    let f_y = Math.floor(y);
    ctx.beginPath();
    ctx.ellipse(f_x, f_y, rw, rh, 0, 0, tau);
    ctx.fillStyle = color;
    ctx.fill()
}

function Point(x, y) {
    this.x = x;
    this.y = y;
}

setTimeout(() => {
    connect();
}, 500)

function initGame() {
    gameInt = setInterval(tick, 1);
    //load frames
    for (let img of frameHtmlImgs) {
        clearCanvas(frameloader, fl_ctx);
        fl_ctx.drawImage(img, 0,0);
        frames.push(getFrameData())
    }

    for (let img of tileHtmlImgs) {
        clearCanvas(frameloader, fl_ctx);
        fl_ctx.drawImage(img, 0,0)
        tileimgdata.push(getFrameData(true))
    }

    //load into worldframes

    for (let f in frames) {
        loadFrameimgdata(frames[f])
    }
    clearCanvas(renderer, ctx);

    //worldframeorder = [0,1,2,3,4,5] from server instead
    for (let i of worldframeorder) {
        worldframeimgdatas.push(worldframes[i])
    }

    setupInputs();

    flushToCanvas()
    if (typeof loadmsg !== 'undefined') loadmsg.parentNode.removeChild(loadmsg);

}


function loadFrameimgdata(frame) {
    clearCanvas(renderer, ctx);
    //draw all tiles to canvas
    let f = frame;
    for (let r = 0; r < f.length; r++){
        for (let c = 0; c < f[0].length; c++){
            let tileid = f[r][c]
            if (tileid != null) {
                ctx.putImageData(tileimgdata[tileid], c*32, r*32);
            }
            //else {
            //}
        }
    }
    //store in frameimgdata(temp)
    let fd = ctx.getImageData(0, 0, W, H)
    //push to worldframeimgdatas
    worldframes.push(fd);
}

function update() {
    // moveCamera()
    player.update()
    if (bombs[mySID]) {
        for(let i = 0; i < bombs[mySID].length; i++) {
            bombs[mySID][i].update();
        }
    }

    sendServerTick()
    lastKeys = JSON.parse(JSON.stringify(keys)); //deep copy
}

function sendServerTick() {
    let mybombs = [];
    for (let bomb of bombs[mySID]) {
        mybombs.push(bomb.getAsObj())
    }
    socket.send(newPacket(TICK, {
        p: {
            x: player.x,
            y: player.y,
            w: player.w,
            h: player.h,
            color: 'blue'
        },
        b: mybombs
    }));
}

function moveCamera() {
    // if(camerax + cameravx < (worldframeimgdatas.length - 1) * W) {
    //     camerax += cameravx;
    // } else {
    //     camerax = (worldframeimgdatas.length - 1) * W
    // }
}

function tick() {
    if (Date.now() - lastTime > 10) {
        lastTime = Date.now();
        update();
    }
    draw();
    Particles.update();
}


function flushToCanvas() {
    vis_ctx.drawImage(renderer, 0, 0); //flush to canvas
    if (playing) requestAnimationFrame(flushToCanvas);
}

function getFrameData(istile=false) {
    let valid = false;
    let w = 24
    let h = 16
    if (istile) {
        w = 32;
        h = 32;
    }
    data = []
    raw_data = fl_ctx.getImageData(0, 0, w, h)
    if (istile) return raw_data;
    raw_data = raw_data.data
    for (let row = 0; row < h; row++) {
        data.push([])
        for (let col = 0; col < w; col++) {
            let pos = 4 * (col + row*w);
            let colorstr = raw_data.slice(pos, pos+4).toString();
            let tileid = TILES[colorstr]
            if (tileid != 0) valid = true;
            data[row].push(tileid);
        }
    }
    if (!valid && !istile) console.log('thats a solid block buddy')
    return data
}

function setWorldAlpha(x, y, val) {
    let framenum = Math.floor(x / W);
    if (framenum < 0) return;
    x = (x+W) % W
    framenum %= worldframeorder.length;
    let myframe = worldframeimgdatas[framenum];
    let pos = 4 * (x + y*W) + 3;
    if(pos > myframe.data.length) return
    myframe.data[pos] = val;
}

function getWorldAlpha(x, y) {
    let framenum = Math.floor(x / W);
    if (framenum < 0) return 0;
    x = (x+W) % W
    framenum %= worldframeorder.length;
    let myframe = worldframeimgdatas[framenum];
    return getAlpha(myframe, y, x);
}

function getAlpha(frameimgdata, row, col) {
    let pos = 4 * (col + row*W) + 3;
    return frameimgdata.data[pos];
}


function clearCanvas(canvasobj, canvas_ctx) {
    canvas_ctx.clearRect(0, 0, canvasobj.width, canvasobj.height);
}

function drawworldframe() {
    let framenum1 = Math.floor(camerax / W) % worldframeorder.length; //first frame to draw
    let framenum2 = (framenum1 + 1) % worldframeorder.length; //second frame to draw
    clearCanvas(alphacanvas, a_ctx)
    a_ctx.putImageData(worldframeimgdatas[framenum1],Math.floor(-camerax%W),0)
    a_ctx.putImageData(worldframeimgdatas[framenum2],Math.floor(-camerax%W + W), 0)
    ctx.drawImage(alphacanvas, 0, 0)

}

function draw() {
    clearCanvas(renderer, ctx);
    let backgroundColor = '#337'
    ctx.fillStyle = backgroundColor
    ctx.fillRect(0, 0, W, H);

    drawworldframe();


    Particles.draw(ctx, camerax)
    
    for(let p of otherplayers) {
        drawPlayer(p.x, p.y, p.w, p.h, p.color)
    }
    player.draw();
    for(let i = 0; i < bombs.length; i++) {
        for(let j = 0; j < bombs.length; j++) {
            let b = bombs[i][j]
            if (b) drawBomb(b.x, b.y, b.rw, b.rh, 'black')
        }
    }
}

function explode(ox, oy, range) {
    ox = Math.floor(ox);
    oy = Math.floor(oy);
    Particles.explode(ox, oy, 'orange', range/10)
    throwPlayer(ox, oy, range);    
    for (let y = oy - range; y < oy + range; y++) {
        for (let x = ox - range; x < ox + range; x++) {
            let ydist = y-oy;
            let xdist = x-ox;
            if (ydist*ydist + xdist*xdist <= range*range) {
                setWorldAlpha(x, y, 0)
            }
        }
    }
}

function throwPlayer(x, y, range) {
    let pcx = player.x + player.w/2;
    let pcy = player.y + player.h/2;
    let dx = pcx - x;
    let dy = pcy - y
    if(Math.abs(dx) < 2*range && Math.abs(dy) < 2*range) {
        let dc = Math.sqrt(dx ** 2 + dy ** 2)
        let vx = dx / Math.abs(dx) / dc * 1000
        let vy = dy / Math.abs(dy) / dc * 500
        player.vx += vx
        player.vy += vy
    }
}

/* returns Point(x,y)
 * y: suggested relocation
 * x: collision position
 */
 function findYCollisionDown(y, vy, x, width, height) {
    vy = Math.round(vy);
    if (vy <= 0) return null;
    y = Math.floor(y);
    x = Math.floor(x);
    let bottom = y + height
    for (let r = bottom; r < bottom + vy; r++) {
        if (r >= H) return new Point(x, H - height);
        for (let c = x; c < x + width; c++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c, r - height);
            }
        }
    }
    return null;
}
function findYCollisionUp(y, vy, x, width, height) {
    vy = Math.round(vy);
    if (vy >= 0) return null;
    y = Math.floor(y);
    x = Math.floor(x);
    for (let r = y-1; r > y + vy-1; r--) {
        if (r <= 0) return new Point(x, 0);
        for (let c = x; c < x + width; c++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c, r+1);
            }
        }
    }
    return null;
}
/* returns Point(x,y)
 * y: collision position
 * x: suggested relocation
 */
function findXCollisionRight(x, vx, y, width, height) {
    vx = Math.round(vx);
    if (vx <= 0) return null;
    x = Math.floor(x);
    y = Math.floor(y);
    let right = x + width;
    for (let c = right; c < right + vx; c++) {
        // if (c >= camerax + W) return new Point(c - width, y); //right edge
        for (let r = y; r < y + height; r++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c - width, r);
            }
        }
    }
    return null
}
function findXCollisionLeft(x, vx, y, width, height) {
    vx = Math.round(vx);
    if (vx >= 0) return null;
    x = Math.floor(x);
    y = Math.floor(y);
    for (let c = x-1; c > x + vx-1; c--) {
        // if (c <= camerax) return new Point(camerax, y); //left edge
        for (let r = y; r < y + height; r++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c+1, r);
            }
        }
    }
    return null;
}


function setupInputs() {
    onkeydown = e => {
        let k = e.keyCode;
        keys[k] = true;
    }
    
    onkeyup = e => {
        let k = e.keyCode;
        keys[k] = false;
    }
    
    canvas.onmousemove = e => {
        mouseX = e.offsetX
        mouseY = e.offsetY
    }

    canvas.onmousedown = e => {
        let k = e.button;
        keys[k] = true;
    }
    canvas.onmouseup = e => {
        let k = e.button;
        keys[k] = false;
    }

    canvas.oncontextmenu = e => {
        e.preventDefault();
        explode(e.offsetX + camerax, e.offsetY, 100)

    }
}

function getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
    results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

</script>
