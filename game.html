<!DOCTYPE html>
<html>
<meta charset="UTF-8">
    <title>THE GAME TITLE!</title>
</head>
<body>
    <div id="loadmsg">
        Loading...
    </div>
    <canvas id="canvas" width="768" height="512"></canvas>
    <canvas hidden id="renderer" width="768" height="512"></canvas>
    <canvas hidden id="alphacanvas" width="768" height="512"></canvas>
    <canvas hidden id="frameloader" width="32" height="32"></canvas>
<!-- alphacanvas: https://weblogs.asp.net/bleroy/drawing-transparent-glyphs-on-the-html-canvas-->
</body>
<img hidden id='frame1' src='baseframe1.png' alt='img'>
<img hidden id='frame2' src='baseframe2.png' alt='img'>
<img hidden id='frame3' src='baseframe3.png' alt='img'>
<img hidden id='tileimg' src='tile.png' alt='img'>

<script type="text/javascript" src="particles.js"></script>
<script type="text/javascript">
var canvas = document.getElementById('canvas')
var renderer = document.getElementById('renderer')
var frameloader = document.getElementById('frameloader')
var alphacanvas = document.getElementById('alphacanvas')
var vis_ctx = canvas.getContext('2d')
var ctx = renderer.getContext('2d')
var fl_ctx = frameloader.getContext('2d')
var a_ctx = alphacanvas.getContext('2d')
var keys = {};
var lastKeys = {};
var lastTime

let W = renderer.width
let H = renderer.height
const TILES = {
    '0,0,0,0': null, //background
    '0,0,0,255': 0, //blocks
}
const GRAVITY = 1;
const FRICTION = .85;
var tileimgdata = []
var worldframeimgdatas = []
var worldframes = []
var frames = []
var camerax = 0;
var lastTime = Date.now();

const frameHtmlImgs = [
    frame1,
    frame2,
    frame3,
]
const tileHtmlImgs = [
    tileimg,
]

var player = {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    w: 32,
	h: 64,
    ax: .6,
	jv: -18,
	mvx: 50,
	mvy: 20,
	jumps: 1,
    step_h: 16,
	midair: true,
    draw() {
        ctx.fillStyle = 'red';
        let f_x = Math.floor(this.x - camerax);
        let f_y = Math.floor(this.y);
        ctx.fillRect(f_x, f_y, this.w, this.h, this.color);
    },
    update() {
        this.vy += GRAVITY;
        if (keys[37] || keys[65]) { //left
            this.vx -= this.ax;
            if (this.vx < -this.maxv)
                this.vx = -this.maxv;
        }
        if (keys[39] || keys[68]) { //right
            this.vx += this.ax;
            if (this.vx > this.maxv)
                this.vx = this.maxv;
        }
        if (this.jumps && (keys[38] || keys[87]) && (!lastKeys[38] && !lastKeys[87])) { //up
            this.vy = -18;
        }
        if (this.vy >= 0) { //moving down
            let y_cls = findYCollisionDown(this.y, this.vy, this.x, this.w, this.h);
            if (y_cls == null) {
                this.y += this.vy;
                this.midair = true;
            } else { //landed on something
                this.vy = 0;
                this.y = y_cls.y;
                this.midair = false;
            }
        } else { //moving up
            let y_cls = findYCollisionUp(this.y, this.vy, this.x, this.w, this.h);
            this.midair = true;
            if (y_cls == null) {
                this.y += this.vy;
            } else { //hit your head
                this.vy = 0;
                this.y = y_cls.y;
                this.midair = false;
            }
        }
        if (this.vx > 0) { //moving right
            let x_cls = findXCollisionRight(this.x, this.vx, this.y, this.w, this.h);
            if (x_cls == null) this.x += this.vx;
            else { //hit wall
                let step_h = this.y + this.h - x_cls.y;
                if (step_h <= this.step_h) {
                    this.x = x_cls.x + 1;
                    this.y -= step_h; //not implemented: climbing more than 1 step
                } else {
                    this.vx = 0;
                    this.x = x_cls.x;
                }
            }
        } else if(this.vx < 0) { //moving left
            let x_cls = findXCollisionLeft(this.x, this.vx, this.y, this.w, this.h);
            if (x_cls == null) this.x += this.vx;
            else { //hit wall
                let step_h = this.y + this.h - x_cls.y;
                if (step_h <= this.step_h) {
                    this.x = x_cls.x - 1;
                    this.y -= step_h; //not implemented: climbing more than 1 step
                } else {
                    this.vx = 0;
                    this.x = x_cls.x;
                }
            }
        }
        this.vx *= FRICTION;
        if (Math.abs(this.vx) - .01 < 0) {
            this.vx = 0;
        }
    }
}

function Point(x, y) {
    this.x = x;
    this.y = y;
}

setTimeout(() => {
    init();
}, 500)

function init() {
    gameInt = setInterval(tick, 1);
    //load frames
    for (let img of frameHtmlImgs) {
        clearCanvas(frameloader, fl_ctx);
        fl_ctx.drawImage(img, 0,0);
        frames.push(getFrameData())
    }

    for (let img of tileHtmlImgs) {
        clearCanvas(frameloader, fl_ctx);
        fl_ctx.drawImage(img, 0,0)
        tileimgdata.push(getFrameData(true))
    }

    //load into worlddata

    worldframes = [0,2,0]
    for (let f of worldframes) {
        loadFrameimgdata(frames[f])
    }
    clearCanvas(renderer, ctx);

    flushToCanvas()
    if (typeof loadmsg !== 'undefined') loadmsg.parentNode.removeChild(loadmsg);
}


function loadFrameimgdata(frame) {
    clearCanvas(renderer, ctx);
    //draw all tiles to canvas
    let f = frame;
    for (let r = 0; r < f.length; r++){
        for (let c = 0; c < f[0].length; c++){
            if (f[r][c] == 0) {
                ctx.putImageData(tileimgdata[0], c*32, r*32);
            }
            //else {
            //}
        }
    }
    //store in frameimgdata(temp)
    let fd = ctx.getImageData(0, 0, W, H)
    //push to worldframeimgdatas
    worldframeimgdatas.push(fd);
}

function update() {
    player.update()
    lastKeys = JSON.parse(JSON.stringify(keys)); //deep copy
}

function tick() {
    if (Date.now() - lastTime > 10) {
        lastTime = Date.now();
        update();
    }
    draw();
    Particles.update();
}


function flushToCanvas() {
    vis_ctx.drawImage(renderer, 0, 0); //flush to canvas
    requestAnimationFrame(flushToCanvas);
}

function getFrameData(istile=false) {
    let valid = false;
    let w = 24
    let h = 16
    if (istile) {
        w = 32;
        h = 32;
    }
    data = []
    raw_data = fl_ctx.getImageData(0, 0, w, h)
    if (istile) return raw_data;
    raw_data = raw_data.data
    for (let row = 0; row < h; row++) {
        data.push([])
        for (let col = 0; col < w; col++) {
            let pos = 4 * (col + row*w);
            let colorstr = raw_data.slice(pos, pos+4).toString();
            let tileid = TILES[colorstr]
            if (tileid != 0) valid = true;
            data[row].push(tileid);
        }
    }
    if (!valid && !istile) console.log('thats a solid block buddy')
    return data
}

function setWorldAlpha(x, y, val) {
    let framenum = Math.floor(x / W);
    x = x % W
    let myframe = worldframeimgdatas[framenum];
    let pos = 4 * (x + y*W) + 3;
    myframe.data[pos] = val;
}

function getWorldAlpha(x, y) {
    let framenum = Math.floor(x / W);
    x = x % W
    let myframe = worldframeimgdatas[framenum];
    return getAlpha(myframe, y, x);
}

function getAlpha(frameimgdata, row, col) {
    let pos = 4 * (col + row*W) + 3;
    return frameimgdata.data[pos];
}


function clearCanvas(canvasobj, canvas_ctx) {
    canvas_ctx.clearRect(0, 0, canvasobj.width, canvasobj.height);
}

function draw() {
    let framenum = Math.floor(camerax / W); //first frame to draw
    clearCanvas(renderer, ctx);
    let backgroundColor = '#337'
    ctx.fillStyle = backgroundColor
    ctx.fillRect(0, 0, W, H);
    clearCanvas(alphacanvas, a_ctx)
    a_ctx.putImageData(worldframeimgdatas[framenum],-camerax%W,0)
    a_ctx.putImageData(worldframeimgdatas[framenum+1],-camerax%W + W, 0)
    ctx.drawImage(alphacanvas, 0, 0)

    Particles.draw(ctx)
    player.draw();
}

function explode(ox, oy, range) {
    Particles.explode(ox, oy, 'red', 100)
    for (let y = oy - range; y < oy + range; y++) {
        for (let x = ox - range; x < ox + range; x++) {
            let ydist = y-oy;
            let xdist = x-ox;
            if (ydist*ydist + xdist*xdist <= range*range) {
                setWorldAlpha(x, y, 0)
            }
        }
    }
}

/* returns Point(x,y)
 * y: suggested relocation
 * x: collision position
 */
 function findYCollisionDown(y, vy, x, width, height) {
    vy = Math.round(vy);
    if (vy <= 0) return null;
    y = Math.floor(y);
    x = Math.floor(x);
    let bottom = y + height
    for (let r = bottom; r < bottom + vy; r++) {
        if (r >= H) return new Point(x, H - height);
        for (let c = x; c < x + width; c++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c, r - height);
            }
        }
    }
    return null;
}
function findYCollisionUp(y, vy, x, width, height) {
    vy = Math.round(vy);
    if (vy >= 0) return null;
    y = Math.floor(y);
    x = Math.floor(x);
    for (let r = y-1; r > y + vy-1; r--) {
        if (r <= 0) return new Point(x, 0);
        for (let c = x; c < x + width; c++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c, r+1);
            }
        }
    }
    return null;
}
/* returns Point(x,y)
 * y: collision position
 * x: suggested relocation
 */
function findXCollisionRight(x, vx, y, width, height) {
    vx = Math.round(vx);
    if (vx <= 0) return null;
    x = Math.floor(x);
    y = Math.floor(y);
    let right = x + width;
    for (let c = right; c < right + vx; c++) {
        for (let r = y; r < y + height; r++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c - width, r);
            }
        }
    }
    return null
}
function findXCollisionLeft(x, vx, y, width, height) {
    vx = Math.round(vx);
    if (vx >= 0) return null;
    x = Math.floor(x);
    y = Math.floor(y);
    for (let c = x-1; c > x + vx-1; c--) {
        for (let r = y; r < y + height; r++) {
            if (getWorldAlpha(c, r) !== 0) {
                return new Point(c+1, r);
            }
        }
    }
    return null;
}

onkeydown = e => {
	let k = e.keyCode;
	keys[k] = true;
}

onkeyup = e => {
	let k = e.keyCode;
	keys[k] = false;
}

</script>
